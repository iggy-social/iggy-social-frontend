import{m as K,p as w,q as F,s as q,v as Z,x as ee,y as $,z as N,A as y,B as x,k as U,W as te}from"./entry.f8784ff1.js";var ne=Object.defineProperty,re=(t,e,n)=>e in t?ne(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,f=(t,e,n)=>(re(t,typeof e!="symbol"?e+"":e,n),n),j=(t,e,n)=>{if(!e.has(t))throw TypeError("Cannot "+n)},s=(t,e,n)=>(j(t,e,"read from private field"),n?n.call(t):e.get(t)),S=(t,e,n)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,n)},b=(t,e,n,o)=>(j(t,e,"write to private field"),o?o.call(t,n):e.set(t,n),n),E=(t,e,n)=>(j(t,e,"access private method"),n);class ae{constructor(e){f(this,"options"),this.options=e}}var O=(t=>(t.rabby="io.rabby",t.metamask="io.metamask",t.brave="com.brave.wallet",t.coinbase="com.coinbase.wallet",t.bitget="com.bitget.web3wallet",t))(O||{});class oe extends Error{constructor(e,n,o,a){if(!Number.isInteger(e))throw new Error('"code" must be an integer.');if(!n||typeof n!="string")throw new Error('"message" must be a nonempty string.');super(n),f(this,"code"),f(this,"data"),f(this,"internal"),this.code=e,this.data=a,this.internal=o}}class Y extends oe{constructor(e,n,o,a){if(!(Number.isInteger(e)&&e>=1e3&&e<=4999))throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');super(e,n,o,a)}}class se extends Error{constructor(e){super(),f(this,"name","ConnectorNotFoundError"),f(this,"message","VueDappError: Connector not found"),e&&(this.message=this.message+": "+e)}}class C extends Error{constructor(e){super(),f(this,"name","ProviderNotFoundError"),f(this,"message","VueDappError: Provider not found"),e&&(this.message=this.message+": "+e)}}class z extends Error{constructor(){super(...arguments),f(this,"name","AddChainError"),f(this,"message","VueDappError: Error adding chain")}}class ie extends Y{constructor(e){super(4902,e.message),f(this,"name","SwitchChainError")}}class G extends Y{constructor(e){super(4001,e.message),f(this,"name","UserRejectedRequestError")}}class ce extends Error{constructor(e){super(e),f(this,"name","ConnectError")}}class B extends Error{constructor(e){super(),f(this,"name","AssertConnectedError"),e&&(this.message=this.message+": "+e)}}function le(t){return"0x"+t.toString(16)}function ge(t,e=6,n=4){return typeof t!="string"||!t?"":t.slice(0,e)+"..."+t.slice(-n)}function R(t){return typeof t=="string"?Number.parseInt(t,t.trim().substring(0,2)==="0x"?16:10):typeof t=="bigint"?Number(t):t}function I(t,e){if(t.status!=="connected")throw new B(e+" - status");if(!t.connectorName)throw new B(e+" - connectorName");if(!t.provider)throw new B(e+" - provider");if(!t.connector)throw new B(e+" - connector");if(!t.address)throw new B(e+" - address");if(!t.chainId)throw new B(e+" - chainId")}const Q=typeof window<"u"&&!!window.ethereum,J=K("vd-store",()=>{const t=F([]),e=F([]),n=F({status:"idle",error:null,connectorName:null,provider:null,connector:null,address:null,chainId:null,providerInfo:null,providerTarget:null}),o=q(null),a=q(null),i=q(null);return{connectors:t,providerDetails:e,wallet:n,...Z(n),onDisconnectCallback:o,onAccountsChangedCallback:a,onChainChangedCallback:i}});function M(t){const e=J(t);function n(){const l=u=>{a(u.detail)};return window.addEventListener("eip6963:announceProvider",l),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",l)}function o(){}function a(l){e.providerDetails.some(({info:u})=>u.uuid===l.info.uuid)||e.providerDetails.push(l)}function i(l){return e.providerDetails.find(({info:u})=>u.rdns===l)}return{providerDetails:w(()=>e.providerDetails),hasInjectedProvider:w(()=>typeof window<"u"&&!!window.ethereum),isProviderAnnounced:w(()=>e.providerDetails.length>0),subscribe:n,getProviderDetail:i,removeListener:o}}var h,k,W,A,D,P,T,V;class pe extends ae{constructor(e={}){super(e),S(this,D),S(this,T),f(this,"name","BrowserWallet"),S(this,h,void 0),S(this,k,void 0),S(this,W,void 0),S(this,A,void 0),M().subscribe()}async connect(e){const{target:n,rdns:o,timeout:a}=e,{provider:i,info:l}=this.getProvider(n,o);let u,c;try{a?u=await Promise.race([i.request({method:"eth_requestAccounts"}),new Promise((v,p)=>setTimeout(()=>{p(new Error("timeout"))},a))]):u=await i.request({method:"eth_requestAccounts"}),c=await i.request({method:"eth_chainId"})}catch(v){throw new Error(`Failed to request accounts${v.message?": "+v.code+" "+v.message:""}`)}return b(this,h,i),{provider:s(this,h),account:u[0],chainId:c,info:l}}getProvider(e,n){switch(e){case"window.ethereum":const o=this.getProviderByWindowEthereum();if(!o)throw new C("No provider found by window.ethereum");return{provider:o,info:void 0};case"rdns":if(!n)throw new Error("rdns is required");const a=this.getProviderByRdns(n);if(!a)throw new C("No provider found by the given rdns");return{provider:a.provider,info:a.info};default:throw new Error("target is required")}}getProviderByWindowEthereum(){if(typeof window<"u"&&window.ethereum)return window.ethereum}getProviderByRdns(e){const{providerDetails:n}=M();if(!n.value.length)throw new C("No providerDetails found");return n.value.find(({info:o})=>o.rdns===e)}async disconnect(){if(!s(this,h))throw new C;s(this,k)&&E(this,D,P).call(this,"disconnect",s(this,k)),s(this,W)&&E(this,D,P).call(this,"accountsChanged",s(this,W)),s(this,A)&&E(this,D,P).call(this,"chainChanged",s(this,A)),b(this,h,void 0),b(this,k,void 0),b(this,W,void 0),b(this,A,void 0)}onDisconnect(e){if(!s(this,h))throw new C;s(this,k)&&E(this,D,P).call(this,"disconnect",s(this,k)),b(this,k,e),s(this,h).on("disconnect",e)}onAccountsChanged(e){if(!s(this,h))throw new C;s(this,W)&&E(this,D,P).call(this,"accountsChanged",s(this,W)),b(this,W,e),s(this,h).on("accountsChanged",e)}onChainChanged(e){if(!s(this,h))throw new C;s(this,A)&&E(this,D,P).call(this,"chainChanged",s(this,A)),b(this,A,e),s(this,h).on("chainChanged",n=>{const o=R(n);e(o)})}async addERC20Token(e){if(!s(this,h))throw new C;try{await s(this,h).request({method:"wallet_watchAsset",params:{type:"ERC20",options:{address:e.address,symbol:e.symbol,decimals:e.decimals,image:e.image}}})}catch{throw new Error("Failed to add ERC20 token to MetaMask")}}async switchChain(e,n){if(!s(this,h))throw new C;const o=le(e);try{await s(this,h).request({method:"wallet_switchEthereumChain",params:[{chainId:o}]})}catch(a){if(a.code===4902)try{await this.addChain(n)}catch(i){throw E(this,T,V).call(this,i)?new G(i):new z}throw E(this,T,V).call(this,a)?new G(a):new ie(a)}}async addChain(e){if(!s(this,h))throw new C;try{s(this,h).request({method:"wallet_addEthereumChain",params:[e]})}catch{throw new z}}}h=new WeakMap,k=new WeakMap,W=new WeakMap,A=new WeakMap,D=new WeakSet,P=function(t,e){if(!s(this,h))throw new C;s(this,h).removeListener(t,e)},T=new WeakSet,V=function(t){return/(user rejected)/i.test(t.message)};function X(t){const e=J(t);function n(i){return e.connectors.some(l=>l.name===i)}function o(i){if(e.connectors.find(l=>l.name===i.name))throw new Error(`Connector ${i.name} already added`);e.connectors.push($(i))}function a(i){i.forEach(l=>o(l))}return{connectors:w(()=>e.connectors),addConnector:o,addConnectors:a,hasConnector:n}}const _="VUE_DAPP";function de(t){window.localStorage.setItem(_,JSON.stringify({lastConnectedWalletRdns:t}))}function he(){const t=window.localStorage.getItem(_);if(t)try{const{lastConnectedWalletRdns:e}=JSON.parse(t);e&&window.localStorage.setItem(_,JSON.stringify({lastConnectedWalletRdns:void 0}))}catch{return}}function ue(){const t=window.localStorage.getItem(_);if(t)try{const{lastConnectedWalletRdns:e}=JSON.parse(t);return e}catch{return}}function L(t){const e=J(t);async function n(){e.wallet.status="idle",e.wallet.error=null,e.wallet.connectorName=null,e.wallet.provider=null,e.wallet.connector=null,e.wallet.address=null,e.wallet.chainId=null,e.wallet.providerInfo=null,e.wallet.providerTarget=null}async function o(c,v){e.wallet.error="",e.wallet.status="connecting";const p=e.connectors.find(r=>r.name===c);if(!p)throw new se;try{const{provider:r,account:d,chainId:g,info:m}=await p.connect(v);p.name==="BrowserWallet"&&(e.wallet.providerInfo=m||null,e.wallet.providerTarget=v?.target||null),e.wallet.connector=p,e.wallet.connectorName=p.name,e.wallet.provider=r,e.wallet.address=d,e.wallet.chainId=R(g),e.wallet.status="connected",m!=null&&m.rdns&&de(m.rdns)}catch(r){throw await a(),e.wallet.error=r.message,new ce(r)}e.wallet.connector.onDisconnect((...r)=>{e.onDisconnectCallback&&e.onDisconnectCallback(...r),e.wallet.connectorName!=="BrowserWallet"&&a()}),e.wallet.connector.onAccountsChanged(async r=>{if(e.onAccountsChangedCallback&&e.onAccountsChangedCallback(r),!r.length){a();return}e.wallet.address=r[0]}),e.wallet.connector.onChainChanged(async r=>{e.onChainChangedCallback&&e.onChainChangedCallback(R(r)),e.wallet.chainId=R(r)})}async function a(){try{e.wallet.connector&&await e.wallet.connector.disconnect()}catch(c){throw e.error=`Failed to disconnect, wallet reset: ${c.message}`,new Error(`Failed to disconnect, wallet reset: ${c.message}`)}finally{n(),he()}}function i(c){e.onDisconnectCallback=c}function l(c){e.onAccountsChangedCallback=c}function u(c){e.onChainChangedCallback=c}return{isWindowEthereumAvailable:Q,wallet:ee(e.wallet),status:w(()=>e.wallet.status),error:w(()=>e.wallet.error),connectorName:w(()=>e.wallet.connectorName),provider:w(()=>e.wallet.provider),connector:w(()=>e.wallet.connector),address:w(()=>e.wallet.address),chainId:w(()=>e.wallet.chainId),providerInfo:w(()=>e.wallet.providerInfo),providerTarget:w(()=>e.wallet.providerTarget),isConnected:w(()=>e.wallet.status==="connected"),resetWallet:n,connectTo:o,disconnect:a,onDisconnect:i,onAccountsChanged:l,onChainChanged:u}}function we(t){const{isConnected:e,address:n,chainId:o,wallet:a}=L(t);function i(r,d){return d!=null&&d.immediate&&N(()=>{e.value&&(I(a,"listeners - watchConnected - immediate"),r&&r(y(a)))}),x(e,(g,m)=>{g&&!m&&(I(a,"listeners - watchConnected - watch"),r&&r(y(a)))})}function l(r,d){return d!=null&&d.immediate&&N(()=>{e.value&&(I(a,"listeners - watchAddressChanged - immediate"),r&&r(y(a)))}),x(n,(g,m)=>{m&&g&&(I(a,"listeners - watchAddressChanged - watch"),r&&r(y(a)))})}function u(r,d){return d!=null&&d.immediate&&N(()=>{e.value&&(I(a,"listeners - watchChainIdChanged - immediate"),r&&r(y(a)))}),x(o,(g,m)=>{g&&m&&(I(a,"listeners - watchChainIdChanged - watch"),r&&r(y(a)))})}function c(r,d){d!=null&&d.immediate&&N(()=>{e.value&&(I(a,"listeners - watchAddressChainIdChanged - immediate"),r&&r(y(a)))});const g=l(r),m=u(r);return()=>{g(),m()}}function v(r,d){d!=null&&d.immediate&&N(()=>{e.value&&(I(a,"listeners - watchWalletChanged - immediate"),r&&r(y(a)))});const g=i(r),m=c(r);return()=>{g(),m()}}function p(r,d){return d!=null&&d.immediate&&N(()=>{e.value||r&&r()}),x(e,(g,m)=>{!g&&m&&r&&r()})}return{watchConnected:i,watchAddressChanged:l,watchChainIdChanged:u,watchAddressChainIdChanged:c,watchWalletChanged:v,watchDisconnect:p}}function H(t){return{...X(t),...M(t),...we(t),...L(t)}}function Ce(t){const e=q(!1),n=q(null),{connectors:o}=X(t),{connectTo:a}=L(t);N(async()=>{try{e.value=!0,me()?await i("window.ethereum"):await i("rdns")}catch(l){n.value=l}finally{e.value=!1}});async function i(l){if(!o.value.find(c=>c.name==="BrowserWallet"))return;let u;switch(l){case"window.ethereum":if(!Q)return;u={target:"window.ethereum"};break;case"rdns":const c=ue();if(!c)return;if(c===O.metamask){const{providerDetails:p}=M(),r=p.value.find(d=>d.info.rdns===O.metamask);if(r&&!await r.provider._metamask.isUnlocked())return}u={target:"rdns",rdns:c};break;default:const v=new Error("target is required");throw n.value=v,v}try{await a("BrowserWallet",u)}catch(c){throw n.value=c,c}}return{isAutoConnecting:e,error:n}}function me(){const t=navigator.userAgent;return!!(!t.includes("Safari/")&&t.includes("Mobile/")||t.includes("wv")||t.includes("WebView"))}const fe=K("ethers",{state:()=>({provider:null,signer:null,balance:BigInt(0)}),actions:{async setWallet(t){this.provider=$(new te(t)),this.signer=$(this.provider.getSigner())},resetWallet(){this.provider=null,this.signer=null,this.balance=BigInt(0)},async fetchBalance(){!this.signer||(this.balance=(await this.signer.getBalance()).toBigInt())}}});function ye(){const t=fe();return{...H(U().$pinia),provider:w(()=>t.provider),signer:w(()=>t.signer),balance:w(()=>t.balance),isActivated:w(()=>{const{isConnected:e}=H(U().$pinia);return e.value}),setWallet:t.setWallet,resetWallet:t.resetWallet,fetchBalance:t.fetchBalance}}export{Ce as A,ge as E,O as U,me as f,ye as u,H as w,pe as y};
