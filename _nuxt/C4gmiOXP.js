import{ar as b,as as x,at as F,au as C,av as I,aw as M,ax as E,ay as D,az as w,aA as G,aB as A,aC as T,aD as v,aE as m,aF as H,a5 as R,aG as L,aH as y,aI as N,aJ as P,aK as B,aL as U,aM as j,aN as k,aO as J}from"#entry";function _(e){const{abi:s,data:a}=e,r=b(a,0,4),t=s.find(n=>n.type==="function"&&r===x(F(n)));if(!t)throw new C(r,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:t.name,args:"inputs"in t&&t.inputs&&t.inputs.length>0?I(t.inputs,b(a,4)):void 0}}const p="/docs/contract/encodeErrorResult";function O(e){const{abi:s,errorName:a,args:r}=e;let t=s[0];if(a){const d=M({abi:s,args:r,name:a});if(!d)throw new E(a,{docsPath:p});t=d}if(t.type!=="error")throw new E(void 0,{docsPath:p});const n=F(t),o=x(n);let c="0x";if(r&&r.length>0){if(!t.inputs)throw new D(t.name,{docsPath:p});c=w(t.inputs,r)}return G([o,c])}const h="/docs/contract/encodeFunctionResult";function z(e){const{abi:s,functionName:a,result:r}=e;let t=s[0];if(a){const o=M({abi:s,name:a});if(!o)throw new A(a,{docsPath:h});t=o}if(t.type!=="function")throw new A(void 0,{docsPath:h});if(!t.outputs)throw new T(t.name,{docsPath:h});const n=(()=>{if(t.outputs.length===0)return[];if(t.outputs.length===1)return[r];if(Array.isArray(r))return r;throw new v(r)})();return w(t.outputs,n)}const S="x-batch-gateway:true";async function q(e){const{data:s,ccipRequest:a}=e,{args:[r]}=_({abi:m,data:s}),t=[],n=[];return await Promise.all(r.map(async(o,c)=>{try{n[c]=o.urls.includes(S)?await q({data:o.data,ccipRequest:a}):await a(o),t[c]=!1}catch(d){t[c]=!0,n[c]=K(d)}})),z({abi:m,functionName:"query",result:[t,n]})}function K(e){return e.name==="HttpRequestError"&&e.status?O({abi:m,errorName:"HttpError",args:[e.status,e.shortMessage]}):O({abi:[H],errorName:"Error",args:["shortMessage"in e?e.shortMessage:e.message]})}function W(e,s){if(!R(e,{strict:!1}))throw new L({address:e});if(!R(s,{strict:!1}))throw new L({address:s});return e.toLowerCase()===s.toLowerCase()}class Q extends y{constructor({callbackSelector:s,cause:a,data:r,extraData:t,sender:n,urls:o}){super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],a.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(c=>`    ${N(c)}`)],`  Sender: ${n}`,`  Data: ${r}`,`  Callback selector: ${s}`,`  Extra data: ${t}`].flat(),name:"OffchainLookupError"})}}class V extends y{constructor({result:s,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${N(a)}`,`Response: ${P(s)}`],name:"OffchainLookupResponseMalformedError"})}}class X extends y{constructor({sender:s,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${s}`],name:"OffchainLookupSenderMismatchError"})}}const et="0x556f1830",Y={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function at(e,{blockNumber:s,blockTag:a,data:r,to:t}){const{args:n}=B({data:r,abi:[Y]}),[o,c,d,i,u]=n,{ccipRead:f}=e,g=f&&typeof f?.request=="function"?f.request:Z;try{if(!W(t,o))throw new X({sender:o,to:t});const l=c.includes(S)?await q({data:d,ccipRequest:g}):await g({data:d,sender:o,urls:c}),{data:$}=await U(e,{blockNumber:s,blockTag:a,data:j([i,w([{type:"bytes"},{type:"bytes"}],[l,u])]),to:t});return $}catch(l){throw new Q({callbackSelector:i,cause:l,data:r,extraData:u,sender:o,urls:c})}}async function Z({data:e,sender:s,urls:a}){let r=new Error("An unknown error occurred.");for(let t=0;t<a.length;t++){const n=a[t],o=n.includes("{data}")?"GET":"POST",c=o==="POST"?{data:e,sender:s}:void 0,d=o==="POST"?{"Content-Type":"application/json"}:{};try{const i=await fetch(n.replace("{sender}",s.toLowerCase()).replace("{data}",e),{body:JSON.stringify(c),headers:d,method:o});let u;if(i.headers.get("Content-Type")?.startsWith("application/json")?u=(await i.json()).data:u=await i.text(),!i.ok){r=new k({body:c,details:u?.error?P(u.error):i.statusText,headers:i.headers,status:i.status,url:n});continue}if(!J(u)){r=new V({result:u,url:n});continue}return u}catch(i){r=new k({body:c,details:i.message,url:n})}}throw r}export{Z as ccipRequest,at as offchainLookup,Y as offchainLookupAbiItem,et as offchainLookupSignature};
